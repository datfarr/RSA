#pragma comment(lib, "gmp.lib")
#include <gmp.h>
#include <stdio.h>
#include <string.h>
#include <locale.h>
#include <conio.h>
#include <math.h>

// объявление функций
int Simple( int w); // проверка простых чисел
int gcd(int x, int y); // проверка взаимопростых чисел
int evkl(int b, int c); // расширенный алгоритм Евклида
//unsigned long long int mypow(int x, int y); // возведение в степень типов int 
int powAndMod(int num, int exp, int N); //функция возведения в степень и остаток от деления


// основная программа =============================*****************************************************************************************************


main()   {
int j=0,q,p,N,M,d,len,l;
int s1[80];
char S[80],c,ch;
int e;
FILE *F;
setlocale(0,"RUS");

// ======================= ввод начальных данных ==========================
do {
printf(" Введите большое простое число p = ");
scanf("%d",&p);
if  ( Simple(p)==1) {
	printf ( "Число %d - простое.Можно продолжить. Нажмите enter.\n", p ); break;}
else printf ( "Число %d - составное. Введите заново. \n", p );}
while (Simple(p)==0);
getch();
printf("p=%d\n", p);
   do {
printf(" Введите большое простое число q = ");
scanf("%d",&q);
if  ( Simple(q)==1) {
	printf ( "Число %d - простое.Можно продолжить. Нажмите enter.\n", q ); break;}
else printf ( "Число %d - составное. Введите заново. \n", q );}
while (Simple(q)==0);
getch();
printf("q=%d\n", q);
// =============конец ввода  начальных данных =============================	 



//==========================генерация ключей============================================================
N = p*q; 
printf("N=%d\n", N);// открытый ключ
M = (p-1)*(q-1); // закрытый ключ
printf("M=%d\n", M);


// -----------------------------------находим d
do {
	printf("Введите любое целое число d, которое будет взаимопростым с числом M=%d:", M); // открытый ключ
    scanf("%d", &d);
	gets(S);
    if (gcd(d,M) == 1) {
     printf("Число подходит. Продолжим. Нажмите enter.\n"); break;}
	else printf("Число %d не взаимопростое с числом %d. Введите заново d.\n", d, M);}
while (gcd(d,M)==0);
getch();
// ------------------------------------нашли d


e = evkl(M,d); // закрытый ключ
printf(" найден закрытый ключ e= %f\n", e);

// =========================конец генерации ключей======================================================


printf("Введите сообщение, которое необходимо зашифровать.\n"); // закидываем сообщение в файл
gets(S);
F = fopen ("msg.txt", "w");
fprintf(F,"%s", S);
fclose(F);
getch();

// шифруем открытым ключом==================================
len= strlen(S);
printf("len = %d\n", len);
if ((len >= 1) && (len <= N)) 
{  F = fopen ("msg.txt", "r");
  if ( NULL == fgets ( S, len+1, F ) )
printf ( "Не удалось прочитать строку" );
else {

for (l=0; l<=len-1; l++) {
	ch = S[l];  printf("ch=%d\n", ch);
    s1[l] = powAndMod((int) ch, (int) d, (int) N);  
	printf("s1=%d\n", s1[l]);} } }
fclose(F); 
// конец ===================================================

// кидаем сообщение зашифрованное в файл =======================================
F = fopen ("msg.txt", "w+");
for (l=0; l<=len-1; l++)
fprintf(F,"%d",s1[l]);
fclose(F);
printf("откройте файл, посмотрите что получилось \n");
getch();
// конец =======================================================================

printf("хотите расшифровать сообщение? y/n \n");
c=getchar();
if (c == 'n') printf("До свидания!");
else { printf("Введите закрытый ключ e:");
scanf("%f", &e);
//расшифровка закрытым ключом ==============================================
F = fopen ("msg.txt", "w+");
for (l=0; l<=len-1; l++) {
    ch = powAndMod((int) s1[l], (int) e, (int) N);
	//S[l] = ch;
	fprintf(F,"%c",ch);}
fclose(F);
printf("откройте файл и посмотрите что получилось");
getch();
}
//конец ====================================================================
}
// конец всей программы==============================*****************************************************************************************************

// ==============функция проверки простого числа==================

int Simple ( int w) {
int i;
for ( i=2; i*i<w; i++ )
if ( w % i ==  0 ) return 0; // нашли делитель – составное!
return 1; // не нашли ни одного делителя – простое!

}

// ================ конец функции =================

// ===================== функция проверки взаимопростых чисел===========
int gcd(int x, int y)
{ int k; // буфер

    if (x < y) { k = x; x = y; y = k; }
    while(x != y) {
      k = x % y;
	  if (k==0)  break;
	  x = y;
      y = k;
    }
	if (y==1) return 1;
	else return 0;
    }
// ==================конец функции======================================

//=======================функция расширенного алгоритма Евклида=====================
int evkl(int b, int c)
{ int i, j, x, y, m;
 m = b;
 i = 0;
 j = 1;
 while (c != 0)
 {
   x = b / c;
   y = b % c;
   b = c;
   c = y;
   y = j;
   j = i - j * x;
   i = y;
 }
 if (i < 0) i= i + m;
 return i;
 
}
//=======================конец функции==============================================

//=======================функция возведения в степень и остаток от деления===============================
int powAndMod(int num, int exp, int N) {
	// num число которое нужно возвести в степень
	// exp степень
	// делитель (для остатка от деления)

	mpz_t result; //Объявили переменную для огромного числа

	mpz_init(result); //Инциализация переменной. 
	                  //Чтобы проблем с памятью не было видимо. Без нее не работает

	mpz_ui_pow_ui(result, num, exp); // Возведение в степень. Результат записывается в result.
					 // Приписки "ui" в названии, значит что num и exp типа
					// unsigned int. Функции для просто int нет.
					// Да и кроме выделяемой памяти разницы у них нет 

	mpz_mod_ui(result, result, N);  // Остаток от деления. Результат записывается в result.
					// ui в конце касается переменной N.
					// result на втором месте который это число которое делим.


	return mpz_get_ui(result); //Переконвертировать result в тип unsigned int. 
				   //Наша функция типа int, поэтому автоматом переведется в int 
				   //(число уже не будет таким большим все равно, так что можно :) )
}

/*unsigned long long int mypow(int x, int y) {
int i;
double result;
if (y==0) return 1;
result=x;
for (i=1; i<y; i++) {
result=result * x;
}
return (unsigned long long int)result;
}
*/
//=======================конец функции==============================================
